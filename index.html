<html><title>SHUTTLEDECK</title><link rel="shortcut icon" type="image/x-icon" href="images/favicon.ico" sizes="64x64"/><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"><style>canvas{width:100%;height:100%;}body{margin:0;background:#000;}</style><canvas><script>const canvas = document.getElementsByTagName('canvas')[0];
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true;
ctx.lineCap='round';
ctx.lineJoin='round';

var w, h;
function width() { return w; }
function height() { return h; }

function resize() {
  canvas.width = window.innerWidth * 1;
  canvas.height = window.innerHeight * 1;
  w = canvas.width;
  h = canvas.height;
}resize();
window.addEventListener('resize', resize);

// list of all active game objects
var g = [];

function get() { return g }
function add(obj) { g.push(obj); }
function remove(obj) { g = g.filter((x) => x != obj); }
function clear(obj) { g = []; }

function e() {
  var HANDLES = {};

  return {
    clear: () => HANDLES = {},
    on: (e, handler) => (HANDLES[e] || (HANDLES[e] = [])).push(handler),
    off: (e, handler) => (HANDLES[e] = (HANDLES[e] || []).filter((x) => x != handler)),
    emit: (e, data) => (HANDLES[e] || []).forEach((handler) => handler(data)),
  };
}

// Create global event bus from event emitter
b = new e();
var bus = b;

function pulse(fn, min, max, period) {
  var anim = 0;
  return (dT) => {
    anim += dT;
    fn((Math.sin(anim / period * 6.3) + 1) / 2 * (max - min) + min);
  }
}
function transition$1(duration, fadeOut) {
  var anim = 0;
  this.update = (dT) => {
    anim += dT / duration;
    if (anim > 1 && fadeOut) {
      this.destroyed = true;
      bus.emit('txn-done');
    }
  };
  this.render = (ctx) => {
    var w = width();
    var h = height();
    var tf = 0;
    if (fadeOut) { tf = Math.max(1-anim*anim, 0); }
    else { tf = Math.pow(Math.max(anim-0.3, 0)*1.3, 2);}//1 - Math.exp(-anim*4); }
    // Top plate
    ctx.save();
    ctx.fillStyle = '#443';
    ctx.translate(0, -h*0.6 * tf);
    ctx.fillRect(0, 0, w, h/2);
    ctx.strokeStyle = '#b94';
    ctx.fillStyle = '#b94';
    ctx.lineWidth = w * 0.03;
    ctx.fillRect(0,h/2,w,h*0.05);
    ctx.strokeRect(w*0.25, h*0.2, w*0.5, h*0.2);
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.font=`${w*0.06}px monospace`;
    ctx.fillText('SHUTTLEDECK',w*0.5,h*0.3);
    ctx.restore();

    // Bottom plate
    ctx.save();
    ctx.fillStyle = '#443';
    ctx.translate(0, h*0.6 * tf);
    ctx.fillRect(0, h/2, w, h/2);
    ctx.fillStyle = '#b94';
    ctx.fillRect(0,h*0.55,w,-h*0.05);
    ctx.restore();
  };
}

function drawStars(ctx, x, y, vx, vy) {
  const w = width();
  const h = height();
  const N = Math.sqrt(w * h) / 10;
  ctx.beginPath();
  ctx.strokeStyle = '#aaa';
  ctx.fillStyle = '#ddd';
  ctx.lineWidth = 0.5;
  for (let i = 0; i < N; i++) {
    let s = 1 + (Math.sin(i * i * 1217 + i * i * i * 983) * 0.5 + 0.5) * 5;
    let ax = (1234918 * i * i + i * i * i * i * 2291722 + x * s) % (w+100)-50;
    let ay = (3000182 * i * i * i * i + i * i * i * i * i * 500291 + y * s) % (h+100)-50;
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax+vx*s, ay+vy*s);
    ctx.fillRect(ax-1, ay-1, 2, 2);
  }
  ctx.stroke();
}

function drawCard(ctx, x, y, cs, card, hovering, opacity) {
  ctx.save();

  if (hovering) {
    cs *= 1.04;
  }

  // faded color
  var netColor = `rgba(${card.color[0]},${card.color[1]},${card.color[2]},${opacity})`;

  // dimensions
  var csw = cs / 2;
  var csh = csw * 1.5;

  // position
  ctx.translate(x, y);

  // background
  if (hovering) {
    ctx.fillStyle = `rgb(80,80,80,${0.7 * opacity})`;
  } else {
    ctx.fillStyle = `rgb(50,50,50,${0.7 * opacity})`;
  }
  ctx.fillRect(-csw,-csh,csw*2,csh*2);

  // light sheen
  ctx.save();
  ctx.beginPath();
  ctx.rect(-csw,-csh,csw*2,csh*2);
  ctx.clip();
  ctx.fillStyle = `rgba(220,230,250,${0.3 * opacity})`;
  ctx.rotate(-0.3);
  ctx.translate(cs/2, (Date.now() % 2000) / 1000 * (cs * 5) - cs*1.2);
  ctx.fillRect(-cs*2,0,cs*4,cs*0.2);
  ctx.fillRect(-cs*2,-cs*0.2,cs*4,cs*0.05);
  ctx.restore();

  // outline
  ctx.beginPath();
  ctx.lineWidth = cs / 20;
  ctx.lineJoin = 'round';
  ctx.strokeStyle = netColor;
  ctx.moveTo(-csw, -csh);
  ctx.lineTo(csw, -csh);
  ctx.lineTo(csw, csh);
  ctx.lineTo(-csw, csh);
  ctx.closePath();
  ctx.stroke();

  // glyph
  ctx.save();
  ctx.translate(0, -cs * 0.15);
  card.glyph(ctx, cs);

  // cost
  ctx.translate(0, -cs * 0.52);
  ctx.fillStyle = `rgba(255,255,51,${opacity})`;
  var es = cs * 0.12;
  for (let i = 0; i < card.cost; i++) {
    ctx.fillRect((i - (card.cost - 1) / 2) * es * 1.1 - es * 0.45, 0, es * 0.9, es * 0.9);
  }
  ctx.restore();

  // text
  ctx.fillStyle = netColor;
  ctx.textBaseline = 'middle';
  ctx.font = `${cs/6}px monospace`;
  ctx.textAlign = 'center';
  var lines = card.title;
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], 0, csh * 0.65 + (i - (lines.length - 1) / 2) * csh * 0.2);
  }
  ctx.restore();
}

function drawMineral(ctx, x, y, angle, s) {
  ctx.save();
  ctx.translate(x, y);
  ctx.fillStyle = '#f3f';
  ctx.rotate(angle);
  ctx.fillRect(-s, -s, 2*s, 2*s);
  s *= 0.6;
  ctx.fillStyle = '#fbf';
  ctx.fillRect(-s, -s, 2*s, 2*s);
  ctx.restore();
}

function drawShield(ctx, x, y, r, isFull) {
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 6.28);
  ctx.fill();
  if (isFull) {
    ctx.fillStyle = '#3ff';
    ctx.beginPath();
    ctx.arc(x, y, r*0.65, 0, 6.28);
    ctx.fill();
  }
}

function drawEnergy(ctx, x, y, r, isFull) {
  ctx.fillStyle = '#333';
  ctx.fillRect(x, y, r*0.8, r);
  if (isFull) {
    ctx.fillStyle = '#ff3';
    ctx.fillRect(x + r*0.175, y + r*0.175, r*0.45, r*0.65);
  }
}

function drawDeck(ctx, x, y, s) {
  ctx.save();
  ctx.strokeStyle = '#ccc';
  ctx.fillStyle = '#222';
  ctx.lineWidth = s*0.1;
  var step = s * 0.5;
  ctx.translate(x-step, y+step);
  ctx.fillRect(-s, -s*1.5, 2*s, 3*s);
  ctx.strokeRect(-s, -s*1.5, 2*s, 3*s);
  ctx.translate(step, -step);
  ctx.fillRect(-s, -s*1.5, 2*s, 3*s);
  ctx.strokeRect(-s, -s*1.5, 2*s, 3*s);
  ctx.translate(step, -step);
  ctx.fillRect(-s, -s*1.5, 2*s, 3*s);
  ctx.strokeRect(-s, -s*1.5, 2*s, 3*s);
  ctx.restore();
}

function drawCharPlayer(ctx) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(s*1.2, h + Math.sin(Date.now()*0.003)*s*0.1);
  // Torso
  ctx.fillStyle='#bbb';
  ctx.beginPath();
  ctx.arc(-s*0.1, s*0.1, s*1.4, 0, 6.29);
  ctx.fill();
  // Head
  ctx.fillStyle='#eee';
  ctx.beginPath();
  ctx.arc(0, -s*1.9, s, 0, 6.29);
  ctx.fill();
  // Visor
  ctx.fillStyle='#3af';
  ctx.fillRect(-s*0.1,-s*2.1,s,s*0.4);
  ctx.restore();
}

function drawCharZoren(ctx, col='#3b5') {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(w-s*1.2, h+Math.sin(Date.now()*0.0021+3)*s*0.1);
  // Torso
  ctx.fillStyle=col;//'#8a8';
  ctx.fillRect(-s*0.5,-s*1.5,s*1.4,s*2);
  ctx.fillStyle='#666';
  ctx.fillRect(-s*0.2,-s*1.5,s*0.1,s*2);
  ctx.fillRect(-s*0.35,-s*0.8,s*0.1,s*0.1);
  ctx.fillRect(-s*0.35,-s*0.6,s*0.1,s*0.1);
  // Head
  ctx.fillStyle='#fdb';
  ctx.beginPath();
  ctx.arc(0, -s*1.8, s, 0, 6.29);
  ctx.fill();
  // Glasses
  ctx.fillStyle='#333';
  ctx.fillRect(-s*1,-s*1.95,s*1.6,s*0.1);
  ctx.fillStyle=col;
  ctx.beginPath();
  ctx.arc(-s*0.8,-s*1.8,s*0.3,0,6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.1,-s*1.8,s*0.3,0,6.29);
  ctx.fill();
  ctx.restore();
}

function drawCharWeaponTech(ctx) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(w-s*1.2, h+Math.sin(Date.now()*0.0021+3)*s*0.1);
  // Torso
  ctx.fillStyle='#d72';
  ctx.beginPath();
  ctx.ellipse(s*0.1, s*0.1, s*1.0, s*1.4, 0, 0, 6.29);
  ctx.fill();
  // Head
  ctx.fillStyle='#f94';
  ctx.beginPath();
  ctx.arc(0, -s*1.9, s, 0, 6.29);
  ctx.fill();
  // Ears
  ctx.fillRect(-s*0.8,-s*2.3,s*0.4,-s);
  ctx.fillRect(s*0.4,-s*2.4,s*0.4,-s);
  // Eye
  ctx.fillStyle='#fff';
  ctx.beginPath();
  ctx.ellipse(-s*0.3, -s*2, s*0.5, s*0.3, 0, 0, 6.29);
  ctx.fill();
  ctx.fillStyle='#222';
  ctx.beginPath();
  ctx.arc(-s*0.4, -s*2, s*0.2, 0, 6.29);
  ctx.fill();
  ctx.restore();
}

function drawCharShipMech(ctx) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(w-s*1.2, h+Math.sin(Date.now()*0.0021+3)*s*0.1);
  // Torso
  ctx.fillStyle='#77b';
  ctx.fillRect(-s*1.1, -s*1.5, s*2.2, s*2);
  ctx.fillStyle='#669';
  ctx.fillRect(s*0.9, -s*1.5, s*0.2, s*2);
  // Head
  ctx.fillStyle='#338';
  ctx.fillRect(s*0.5, -s*2.7, s*0.3, s*1.25);
  ctx.fillRect(-s*0.2, -s*2.7, s*0.1, -s*0.8);
  ctx.fillStyle='#55a';
  ctx.fillRect(-s*0.8, -s*2.7, s*1.3, s*1.25);
  // Eyes
  ctx.fillStyle='#ff4';
  ctx.fillRect(-s*0.25, -s*3.4, s*0.2, -s*0.2);
  ctx.fillRect(-s*0.7, -s*2.5, s*0.4, s*0.2);
  ctx.fillRect(-s*0.2, -s*2.5, s*0.4, s*0.2);
  ctx.restore();
}

function drawCharMerchant(ctx) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(w-s*1.2, h+Math.sin(Date.now()*0.0021+3)*s*0.1);
  // Torso
  ctx.fillStyle='#b31';
  ctx.beginPath();
  ctx.ellipse(s*0.4, s*0.1, s*0.8, s*1.8, 0, 0, 6.29);
  ctx.fill();
  // Head
  ctx.fillStyle='#d74';
  ctx.beginPath();
  ctx.arc(0, -s*1.6, s*0.6, 0, 6.29);
  ctx.fill();
  // Eye holders
  ctx.strokeStyle='#d74';
  ctx.beginPath();
  ctx.lineWidth = s * 0.1;
  ctx.moveTo(-s*0.4, -s*2.0);
  ctx.lineTo(-s*0.7, -s*3.0);
  ctx.moveTo(-s*0.1, -s*2.0);
  ctx.lineTo(-s*0.1, -s*3.2);
  ctx.moveTo(s*0.2, -s*2.0);
  ctx.lineTo(s*0.4, -s*3.0);
  ctx.stroke();
  // Eye balls
  ctx.fillStyle='#eee';
  ctx.beginPath();
  ctx.arc(-s*0.7, -s*3.0,s*0.2,0,6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.1, -s*3.2,s*0.2,0,6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s*0.4, -s*3.0,s*0.2,0,6.29);
  ctx.fill();
  // Eye pupils
  ctx.fillStyle='#611';
  ctx.beginPath();
  ctx.arc(-s*0.78, -s*3.0,s*0.1,0,6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.18, -s*3.2,s*0.1,0,6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s*0.32, -s*3.0,s*0.1,0,6.29);
  ctx.fill();
  ctx.restore();
}

function drawCharSmuggler(ctx) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(w-s*1.2, h+Math.sin(Date.now()*0.0021+3)*s*0.1);
  // Torso
  ctx.fillStyle='#343';
  ctx.beginPath();
  ctx.arc(s*0.2, 0, s*0.6, 0, 6.29);
  ctx.fill();
  ctx.fillStyle='#353';
  ctx.beginPath();
  ctx.arc(s*0.5, -s*0.7, s*0.6, 0, 6.29);
  ctx.fill();
  ctx.fillStyle='#363';
  ctx.beginPath();
  ctx.arc(s*0.4, -s*1.4, s*0.6, 0, 6.29);
  ctx.fill();
  // Head
  ctx.fillStyle='#474';
  ctx.beginPath();
  ctx.arc(0, -s*1.9, s*0.8, 0, 6.29);
  ctx.fill();
  // Eyes
  ctx.fillStyle='#3f3';
  ctx.beginPath();
  ctx.arc(-s*0.6, -s*2.1, s*0.07, 0, 6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.4, -s*2.08, s*0.07, 0, 6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.65, -s*1.9, s*0.07, 0, 6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.45, -s*1.88, s*0.07, 0, 6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.62, -s*1.7, s*0.07, 0, 6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.42, -s*1.68, s*0.07, 0, 6.29);
  ctx.fill();
  ctx.restore();
}

function drawCharTemplar(ctx) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(w-s*1.2, h+Math.sin(Date.now()*0.0021+3)*s*0.1-s*0.5);
  // Brain
  ctx.fillStyle='#46c';
  ctx.beginPath();
  ctx.arc(-s*0.2, -s*1.5, s*0.4, 0, 6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s*0.2, -s*1.4, s*0.3, 0, 6.29);
  ctx.fill();
  // Mount
  ctx.fillStyle='rgba(100,100,255,0.3)';
  ctx.beginPath();
  ctx.arc(0, -s*0.95, s*1.1, -3.14, 0);
  ctx.fill();
  ctx.fillStyle='#db3';
  ctx.fillRect(-s*1.2, -s, s*2.4, s*0.3);
  ctx.fillRect(-s*0.6, -s*0.55, s*1.2, s*0.2);
  ctx.fillRect(-s*0.3, -s*0.2, s*0.6, s*0.1);
  ctx.restore();
}

var lineBreaks = (ctx, txt, maxWidth) => {
  var str = '';
  var lines = [];
  for (let i = 0; i < txt.length; i++) {
    str += txt[i];
    if (ctx.measureText(str).width > maxWidth) {
      var ls = str.lastIndexOf(' ');
      var ps = str.substring(0, ls);
      lines.push(ps.trim());
      str = str.substring(ls);
    }
  }
  if (str.trim().length > 0) {
    lines.push(str.trim());
  }
  return lines;
};
var getTextLines = (ctx, txt, w, h, maxWidth) => {
  var r = textLineMap[txt];
  if (r) {
    if (r.w == w && r.h == h) {
      return r.lines;
    }
  }
  var l = lineBreaks(ctx, txt, maxWidth);
  textLineMap[txt] = {w,h,lines:l};
  return l;
};
var textLineMap = {};

function drawDialogBox(ctx, title, txt) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  var ts = Math.max(w * 0.09, h * 0.08);
  ctx.save();
  // Dialog box
  ctx.fillStyle = '#236';
  ctx.strokeStyle = '#3af';
  ctx.lineWidth = s * 0.1;
  ctx.beginPath();
  ctx.moveTo(s*2.8,h*0.75);
  ctx.lineTo(w-s*2.8,h*0.75);
  ctx.lineTo(w-s*2.8,h-s*1.8);
  ctx.lineTo(w-s*2.5,h-s*1.6);
  ctx.lineTo(w-s*2.8,h-s*1.4);
  ctx.lineTo(w-s*2.8,h-s*0.2);
  ctx.lineTo(s*2.8,h-s*0.2);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // title text
  ctx.fillStyle='#ff3';
  ctx.textAlign='left';
  ctx.font=`${ts*0.3}px monospace`;
  ctx.fillText(title, s*3, h*0.75+ts*0.25);

  // title text
  ctx.fillStyle='#fff';
  ctx.textAlign='left';
  ctx.font=`${ts*0.25}px monospace`;

  var lines = getTextLines(ctx, txt, w, h, w - s*6);
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], s*3, h*0.75+ts*(2.1 + i)*0.3);
  }
  // Split line text
  ctx.restore();
}

function drawItemShell(ctx, x, y, s) {
  ctx.save();
  ctx.translate(x, y);
  s/=2;
  ctx.fillStyle = '#333';
  ctx.strokeStyle = '#666';
  ctx.lineWidth = s*0.1;
  ctx.beginPath();
  ctx.arc(0, 0, s, 0, 6.29);
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawItemXeno(ctx, x, y, s) {
  ctx.save();
  ctx.translate(x, y);
  s/=2;
  ctx.fillStyle = '#ccd';
  ctx.fillRect(s*0.07, -s*0.7, s*0.15, s*0.7);
  ctx.beginPath();
  ctx.arc(s*0.1,-s*0.54,s*0.24,0,6.29);
  ctx.fill();
  ctx.fillStyle = '#b94';
  ctx.fillRect(-s*0.6, -s*0.1, s*1.2, s*0.7);
  ctx.fillRect(s*0.3, -s*0.3, s*0.4, s*0.5);
  ctx.fillStyle = '#aaa';
  ctx.textAlign='center';
  ctx.textBaseline='bottom';
  ctx.font=`${s*0.2}px monospace`;
  ctx.fillText('Xenotransponder',0,s*1.4);
  ctx.restore();
}

function StartButton(txt = 'Liftoff') {

  var fn = ({x, y}) => {
    var w = width();
    var uiScale = w * 0.18;
    if (x > w*0.97 - uiScale*2 && x < w*0.97 && y > 0 && y < w*0.02+uiScale*0.8) {
      bus.emit('start');
      bus.off('tap', fn);
    }
  };

  bus.on('tap', fn);

  this.render = (ctx) => {
    var w = width();
    var uiScale = w * 0.18;

    ctx.save();
    ctx.translate(w * 0.97-uiScale,w*0.02+uiScale*0.4);
    var p = (Date.now() % 500) / 500;
    var s = (1-(1-p)*(1-p)) * 0.4 + 0.8;
    ctx.scale(s,s*1.1);
    ctx.strokeStyle = '#0a0';
    ctx.lineWidth = uiScale * 0.1 * (1 - p);
    ctx.strokeRect(-uiScale, -uiScale*0.4, uiScale*2, uiScale*0.8);
    ctx.restore();

    ctx.fillStyle = '#0a0';
    ctx.fillRect(w * 0.97, w*0.02, -uiScale*2, uiScale*0.8);

    ctx.fillStyle = '#fff';
    ctx.font = `${uiScale*0.35}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(txt, w*0.97 - uiScale * 1, w*0.02+uiScale * 0.4);
  };
}

function Audio() {
  var audioCtx = null;
  var sampleRate = null;

  // Sounds to be loaded on init (cursed AudioContext waiting for interaction)
  var gateCloseSound;
  var gateOpenSound;
  var buySound;
  var mineralSound;
  var collisionSound;
  var laneSound;
  var missileSound;
  var laserSound;
  var pulseBreakerSound;
  var hopSound;
  var dashSound;
  var hyperSound;
  var healSound;
  var musicBuffer;
  var rocketBuffer;

  var sin = (i) => Math.min(Math.max(Math.sin(i), -1), 1);
  var saw = (i) => ((i % 6.28)-3.14)/6.28;
  var sqr = (i) => Math.min(Math.max(Math.sin(i) * 1000, -1), 1);
  var win = (i, ts, te) => {
    if (i<ts*44100 || i>te*44100) {return 0;}
    return 1 - ((i/44100) - ts)/(te - ts);
  };
  var note = (i, tone, time, dur) => 0.01*sqr(i / (80/Math.pow(2,tone/12))) * win(i,time,time+dur);
  var hhat = (i, time) => 0.02*Math.random() * win(i,time,time+0.06);

  var generate = (duration, fn, fading = true) => {
    var audioBuffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
    var buffer = audioBuffer.getChannelData(0);
    var N = audioBuffer.length;
    for (var i = 0; i < N; i++) {
      var p = i / N;
      var envelope = 1 - p;
      if (!fading) { envelope = 1; }
      buffer[i] = fn(i*44100/sampleRate) * envelope;
    }
    return audioBuffer;
  };

  this.init = () => {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sampleRate = audioCtx.sampleRate;

    // Transition animation - Gate whirring close
    gateCloseSound = generate(0.6, (i) => {
      return 0.05 * sqr(i/250) * (sin(i/300)+0);
    });

    // Transition animation -  Gate whirring open + noise of steam
    gateOpenSound = generate(1, (i) => {
      return 0.05 * sqr(i/250) * (sin(i/300)+0) + 0.1 * Math.random() * win(i, 0, 1);
    });

    // Buy an item (ding + ding)
    buySound = generate(0.7, (i) => {
      return 0.07 * (saw(i/19) * win(i, 0, 0.15) + saw(i/11) * win(i, 0.1, 0.7));
    });

    // Gain mineral blip + Siphon sound
    mineralSound = generate(0.15, (i) => {
      return 0.04 * sin(i/(15 - i / 2000));
    });

    // Collision / take damage
    collisionSound = generate(0.8, (i) => {
      return 0.1 * Math.random() * win(i, 0, 0.8) * (sqr(i/200)+1);
    });

    // Swap lane
    laneSound = generate(0.4, (i) => {
      return 0.04 * (1+Math.random()/3) * win(i, 0, 0.4) * sin(i/50);
    });

    // Kepler missile + Crazy Rockets + Nuke
    missileSound = generate(0.7, (i) => {
      return 0.04 * Math.random() * win(i, 0, 0.7) * (sqr(i/100) + 1);
    });

    // Sigma cannon / laser
    laserSound = generate(1.5, (i) => {
      return 0.08 * (sin(i/(30-i/400)) * win(i, 0, 0.15) * 3 + saw(i/60)*(sqr(i/400)+1)/2*win(i,0.1,1.5))
    });

    // Pulse breaker
    pulseBreakerSound = generate(1, (i) => {
      return 0.04 * sin(i/50)*(sqr(i/800+1)+1);
    });

    // Hop sound
    hopSound = generate(0.7, (i) => {
      return 0.1 * (
        saw(i/30) * win(i, 0, 0.1) +
        saw(i/50) * win(i, 0.1, 0.2) +
        saw(i/40) * win(i, 0.2, 0.3) +
        saw(i/20) * win(i, 0.3, 0.4) +
        saw(i/10) * win(i, 0.4, 0.5)
      );
    });

    // Dash sound
    dashSound = generate(0.7, (i) => {
      var acc = 0;
      for (let q = 0; q < 10; q++) {
        acc += sin(i/(10+q*q/20)) * win(i, q/10, (q+1)/10);
      }
      return 0.05*acc;
    });

    // Hyperdrive sound
    hyperSound = generate(1.5, (i) => {
      var acc = 0;
      for (let q = 0; q < 13; q++) {
        acc += sqr(i/(10-q*q/15)) * win(i, q/15, (q+1)/15);
        acc += sqr(i/(40-q*q/3)) * win(i, q/15+0.03, (q+1)/15);
      }
      return 0.05*acc;
    });

    // Heal sound
    healSound = generate(0.6, (i) => {
      return 0.04 * sin(i/(50-i/2000))*(sqr(i/700+1)+1);
    });

    musicBuffer = generate(0.2*48, (i) => {
      var d = 0.2;
      var acc = 0;
      for (let q = 0; q < 48; q+=8) {
        acc += hhat(i, d*(q+0))+
          hhat(i, d*(q+1))+
          hhat(i, d*(q+2))*3+
          hhat(i, d*(q+3))+
          hhat(i, d*(q+4))+
          hhat(i, d*(q+6))*3;
      }
      // Phrase 1
      acc += note(i, 12, d * 8, d * 1) +
        note(i, 7, d * 11, d * 1) +
        note(i, 10, d * 14, d * 1.5) +
        note(i, 9, d * 16, d * 1.5) +
        note(i, 3, d * 18, d * 1.5) +
        // Phrase 2
        note(i, 6, d * 32, d * 1) +
        note(i, 3, d * 35, d * 1) +
        note(i, 5, d * 38, d * 1.5) +
        note(i, 3, d * 40, d * 1.5) +
        note(i, 0, d * 42, d * 1.5);
      return acc;
    }, false);

    rocketBuffer = generate(3, (i) => {
      return 0.01 * (saw(i/300)*sqr(i/130) + 1);
    }, false);
  };

  var play = (audioBuffer) => {
    var source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);
    source.start();
  };

  this.setup = () => {
    if (audioCtx == null) { this.init(); }
    bus.on('txn', () => { play(gateCloseSound); });
    bus.on('txn-done', () => { play(gateOpenSound); });
    bus.on('buy', () => { play(buySound); });
    bus.on('mineral', () => { play(mineralSound); });
    bus.on('mine', () => { play(mineralSound); });
    bus.on('hit', () => { play(collisionSound); });
    bus.on('boom', () => { play(collisionSound); });
    bus.on('lane', () => { play(laneSound); });
    bus.on('hop', () => { play(hopSound); });
    bus.on('dash', () => { play(dashSound); });
    bus.on('hyper', () => { play(hyperSound); });
    bus.on('heal', () => { play(healSound); });
    bus.on('projectile', (t) => {
      if (t==1 || t==4 || t==5) {play(missileSound);}
      if (t==2) {play(laserSound);}
      if (t==3) {play(pulseBreakerSound);}
    });
  };

  var musicSource = null;
  this.music = () => {
    if (audioCtx == null) { this.init(); }
    musicSource = audioCtx.createBufferSource();
    musicSource.buffer = musicBuffer;
    musicSource.loop = true;
    musicSource.connect(audioCtx.destination);
    musicSource.start();
  };
  this.bgRocket = () => {
    if (audioCtx == null) { this.init(); }
    musicSource = audioCtx.createBufferSource();
    musicSource.buffer = rocketBuffer;
    musicSource.loop = true;
    musicSource.connect(audioCtx.destination);
    musicSource.start();
  };
  this.stopMusic = () => {
    try {
      if (musicSource != null) { musicSource.stop(); }
    } catch (e) {}
  };
}

var audio = new Audio();

function Steam(x, y) {
  var ttl = Math.random() * 0.4 + 0.2;
  var size = (Math.random() + 1) * width() * 0.02;
  var vy = (Math.random() - 0.5) * height() * 0.08 * size;

  this.update = (dT) => {
    ttl -= dT;
    if (ttl < 0) {
      this.destroyed = false;
    }
    size += size * ttl * dT;
    y += vy * dT;
    vy -= vy * dT * 2.0;
    x -= (Math.random() - 0.5) * size * dT * 5;
  };
  this.render = (ctx) => {
    var opacity = ttl;
    ctx.fillStyle = `rgba(255,255,255,${opacity})`;
    ctx.beginPath();
    ctx.arc(x,y,Math.max(size,1),0,6.29);
    ctx.fill();
  };
}

function Text(str, x, y, color = '#fff', size='1', align='left') {
  this.str = str;
  this.x = x;
  this.y = y;
  this.color = color;
  this.size = size;

  this.render = (ctx) => {
    var uiScale = width() * 0.08;
    ctx.textAlign = align;
    ctx.textBaseline = 'middle';
    ctx.fillStyle = this.color;
    ctx.font = `${this.size * uiScale}px monospace`;
    ctx.fillText(this.str, this.x(), this.y());
  };
}

function MainMenu() {
  // Starfield
  this.render = (ctx) => drawStars(ctx,-Date.now()*0.03,0,3,0);

  // Title card
  add(new Text('SHUTTLEDECK', ()=>width()/2, ()=>height()*0.4, '#fff', 1, 'center'));

  // Push to start pulser
  var pushToStart = new Text('[ Press to start ]', ()=>width()/2, ()=>height()*0.6, '#777', 0.5, 'center');
  pushToStart.ecs = [pulse((x) => {pushToStart.size = x;}, 0.45, 0.55, 1)];
  add(pushToStart);

  // By me :)
  add(new Text('by Ariel Wexler', ()=>width()/2, ()=>height()*0.8, '#f3f', 0.35, 'center'));

  // Touch anywhere to go to intro
  var fn = () => {
    bus.emit('transition-scene', 1);
    bus.off('tap', fn);
  };
  bus.on('tap', fn);
}

const cards = [
{
  color: [255, 51, 51],
  title: ['Rho', 'Channel'],
  cost: 1,
  price: 5,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.beginPath();
    ctx.arc(0, -cs/6, cs / 7, 0, 6.29);
    ctx.stroke();
    ctx.strokeRect(-cs/6, cs/10, cs/3, 0);
    ctx.strokeRect(-cs/6, cs/4, cs/3, 0);
    ctx.restore();
  },
  use: () => { bus.emit('lane', 0); }
},
{
  color: [51, 255, 51],
  title: ['Gamma', 'Sector'],
  cost: 1,
  price: 5,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.beginPath();
    ctx.arc(0, 0, cs / 7, 0, 6.29);
    ctx.stroke();
    ctx.strokeRect(-cs/6, -cs/4, cs/3, 0);
    ctx.strokeRect(-cs/6, cs/4, cs/3, 0);
    ctx.restore();
  },
  use: () => { bus.emit('lane', 1); }
},
{
  color: [51, 51, 255],
  title: ['Beta', 'Stream'],
  cost: 1,
  price: 5,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.beginPath();
    ctx.arc(0, cs/6, cs / 7, 0, 6.29);
    ctx.stroke();
    ctx.strokeRect(-cs/6, -cs/10, cs/3, 0);
    ctx.strokeRect(-cs/6, -cs/4, cs/3, 0);
    ctx.restore();
  },
  use: () => { bus.emit('lane', 2); }
},
{
  // Basic missile that destroys first target in direct line of fire
  color: [255, 160, 30],
  title: ['Kepler', 'Missile'],
  cost: 2,
  price: 10,
  glyph: function (ctx, cs, ls = 0.05) {
    ctx.save();
    ctx.translate(cs/20, 0);
    ctx.rotate(0.6);
    ctx.lineWidth = cs * ls;
    ctx.beginPath();
    ctx.moveTo(-cs/18, -cs/6);
    ctx.lineTo(0, -cs/4);
    ctx.lineTo(cs/18, -cs/6);
    ctx.lineTo(cs/18, cs/4);
    ctx.lineTo(-cs/18, cs/4);
    ctx.closePath();
    ctx.moveTo(-cs/8, cs/4);
    ctx.lineTo(-cs/6, cs/4);
    ctx.lineTo(-cs/8, cs/10);
    ctx.closePath();
    ctx.moveTo(cs/8, cs/4);
    ctx.lineTo(cs/6, cs/4);
    ctx.lineTo(cs/8, cs/10);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('projectile', 1); }
},
{
  // Powerful beam that destroys all content on this channel (good and bad)
  color: [255, 160, 30],
  title: ['Sigma', 'Cannon'],
  cost: 3,
  price: 15,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.translate(cs/12, cs/15);
    ctx.rotate(0.6);
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.moveTo(-cs/4, -cs/4);
    ctx.lineTo(-cs/14, -cs/4);
    ctx.lineTo(-cs/14, -cs/10);
    ctx.lineTo(cs/10, -cs/10);
    ctx.lineTo(cs/10, cs/4);
    ctx.lineTo(-cs/4, cs/4);
    ctx.closePath();
    ctx.moveTo(-cs/6, 0);
    ctx.lineTo(0, 0);
    ctx.lineTo(-cs/12, cs/12);
    ctx.lineTo(0, cs/6);
    ctx.lineTo(-cs/6, cs/6);
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('projectile', 2); }
},
{
  // 3 parallel pulses that break the first obstacle on each channel
  color: [255, 160, 30],
  title: ['Pulse', 'Breaker'],
  cost: 3,
  price: 15,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.translate(-cs/30, 0);
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.arc(0, 0, cs/16, 0, 6.29);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, cs/5, -1, 1);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, cs/3, -0.8, 0.8);
    ctx.stroke();
    ctx.rotate(0.5);
    ctx.strokeRect(-cs/8, -cs/30, -cs/8, cs/15);
    ctx.rotate(-1.0);
    ctx.strokeRect(-cs/8, -cs/30, -cs/8, cs/15);
    ctx.restore();
  },
  use: () => { bus.emit('projectile', 3); }
},
{
  // Twin rockets that will destroy two random obstacles
  color: [255, 160, 30],
  title: ['Crazy', 'Rockets'],
  cost: 2,
  price: 10,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    for (let i = 0; i < 2; i++) {
      ctx.beginPath();
      ctx.moveTo(-cs/4, cs/8);
      ctx.lineTo(-cs/6, -cs/8);
      ctx.lineTo(cs/14, cs/20);
      ctx.lineTo(cs/8, -cs/6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cs/8+cs/12, -cs/6);
      ctx.lineTo(cs/8-cs/12, -cs/6);
      ctx.lineTo(cs/8, -cs/6-cs/8);
      ctx.closePath();
      ctx.stroke();
      ctx.translate(cs/16, cs/5);
      ctx.rotate(0.2);
    }
    ctx.restore();
  },
  use: () => { bus.emit('projectile', 4); }
},
{
  // Blows up everything on the screen
  color: [255, 160, 30],
  title: ['Tactical', 'Nuke'],
  cost: 4,
  price: 20,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.arc(0, 0, cs/3, 0, 6.29);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, cs/20, 0, 6.29);
    ctx.stroke();
    ctx.rotate(0.5);
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(0,0, cs/4, -0.4, 0.4, false);
      ctx.arc(0,0, cs/8, 0.4, -0.4, true);
      ctx.closePath();
      ctx.stroke();
      ctx.rotate(2.1);
    }
    ctx.restore();
  },
  use: () => { bus.emit('projectile', 5); }
},
{
  // Move to a new random channel
  color: [255, 70, 255],
  title: ['Quantum', 'Hopper'],
  cost: 1,
  price: 5,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.arc(0, cs/5, cs/14, 0, 6.29);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, cs/14, 0, 6.29);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, -cs/5, cs/14, 0, 6.29);
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('hop', 2); }
},
{
  // Jump through obstacle in front of you
  color: [255, 70, 255],
  title: ['Shadow', 'Dash'],
  cost: 2,
  price: 10,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.translate(-cs/20, cs/10);
    ctx.rotate(0.6);
    ctx.beginPath();
    ctx.arc(0, 0, cs/10, 0, 6.29);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, -cs/6);
    ctx.lineTo(0, -cs/3);
    ctx.moveTo(0, cs/6);
    ctx.lineTo(0, cs/4);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-cs/12, -cs/3);
    ctx.lineTo(cs/12, -cs/3);
    ctx.lineTo(0, -cs/2);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('dash'); }
},
{
  // Regenerate one shield
  color: [255, 70, 255],
  title: ['Shield', 'Charger'],
  cost: 3,
  price: 15,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.arc(0, 0, cs/4, 0, 6.29);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-cs/7, 0);
    ctx.lineTo(cs/7, 0);
    ctx.moveTo(0, -cs/7);
    ctx.lineTo(0, cs/7);
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('heal'); }
},
{
  // Siphon all minerals on screen toward you
  color: [255, 70, 255],
  title: ['Mineral', 'Siphon'],
  cost: 3,
  price: 15,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    for (let i = 0; i < 3; i++) {
      ctx.save();
      ctx.translate((1-(i-1)*(i-1))*cs/5, (i-1) * cs/5);
      ctx.beginPath();
      ctx.moveTo(-cs/12, 0);
      ctx.lineTo(0, -cs/10);
      ctx.lineTo(cs/12, 0);
      ctx.lineTo(0, cs/10);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-cs/3, 0);
    ctx.moveTo(-cs/8, cs/10);
    ctx.lineTo(-cs/3, 0);
    ctx.moveTo(-cs/8, -cs/10);
    ctx.lineTo(-cs/3, 0);
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('mine'); }
},
{
  // Advance 15% of the journey with no damage
  color: [255, 70, 255],
  title: ['Hyper', 'Drive'],
  cost: 4,
  price: 20,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.moveTo(-cs/6, -cs/4);
    ctx.lineTo(cs/6, -cs/4);
    ctx.lineTo(-cs/6, cs/4);
    ctx.lineTo(cs/6, cs/4);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('hyper'); }
},
{
  // Increase max shield
  color: [0, 255, 255],
  title: ['Defense', 'Blessing'],
  cost: 0,
  price: 25,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.beginPath();
    ctx.arc(0,0,cs/3,0,6.29);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0,0,cs/7,0,6.29);
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('persist-max-shield'); }
},
{
  // Increase max energy
  color: [255, 255, 0],
  title: ['Strength', 'Blessing'],
  cost: 0,
  price: 25,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.translate(0,-cs/10);
    ctx.strokeRect(-cs/4,-cs/6, cs/2,cs*0.6);
    ctx.strokeRect(-cs/10,-cs/4, cs/5,-cs/8);
    ctx.translate(0,cs/7);
    ctx.beginPath();
    ctx.moveTo(-cs/10, -cs/6);
    ctx.lineTo(cs/10, -cs/6);
    ctx.lineTo(-cs/20, 0);
    ctx.lineTo(cs/20, 0);
    ctx.lineTo(0, cs/6);
    ctx.stroke();
    ctx.restore();
  },
  use: () => { bus.emit('persist-max-energy'); }
},
{
  // Increase max hand size
  color: [200, 200, 200],
  title: ['Vision', 'Blessing'],
  cost: 0,
  price: 25,
  glyph: function (ctx, cs) {
    ctx.save();
    ctx.lineWidth = cs * 0.05;
    ctx.lineCap='round';
    ctx.strokeRect(-cs*0.25,0,cs*0.2,cs*0.3);
    ctx.strokeRect(cs*0.05,0,cs*0.2,cs*0.3);
    ctx.strokeRect(-cs*0.1,-cs*0.4,cs*0.2,cs*0.3);
    ctx.restore();
  },
  use: () => { bus.emit('persist-max-hand'); }
},
];

var persist = (() => {
  var minerals = 0;
  var level = 0;
  var handSize = 3;
  var maxEnergy = 5;
  var maxShield = 3;
  var deck = [];

  var a = {
    reset: () => {
      minerals = 0;
      level = 0;
      handSize = 3;
      maxEnergy = 5;
      maxShield = 3;
      deck = [
        cards[0],cards[0],cards[0],
        cards[1],cards[1],cards[1],
        cards[2],cards[2],cards[2],
      ];
    },

    getMinerals: () => minerals,
    addMineral: (m) => minerals += m,

    getLevel: () => level,
    setLevel: (l) => level = l,

    getHandSize: () => handSize,
    setHandSize: (e) => handSize = e,

    getMaxEnergy: () => maxEnergy,
    setMaxEnergy: (e) => maxEnergy = e,

    getMaxShield: () => maxShield,
    setMaxShield: (e) => maxShield = e,

    getDeck: () => deck,
    addToDeck: (c) => deck.push(c),
  };
  a.reset();

  return a;
})();

function Intro() {
  add(new Text('Professor Zorn\'s Lab', ()=>width()*0.03, ()=>width()*0.05, '#fff', 0.5, 'left'));
  add(new StartButton());
  bus.on('start', () => {
    persist.reset();
    bus.emit('transition-scene', 2);
  });

  this.render = (ctx) => {
    var uiScale = height() * 0.3;
    drawCharPlayer(ctx);
    drawCharZoren(ctx);
    drawDialogBox(ctx,
      'Professor Zorn',
      'Hey there Courier, I need your help getting this Xenotransponder to Korva-6. It\'s only a few planets away.'
    );
    drawItemShell(ctx, width()*0.5, height()*0.4,uiScale);
    drawItemXeno(ctx, width()*0.5, height()*0.4,uiScale);
  };
}

function PlayedCard(x, y, card, cs) {
  var anim = 0;

  this.update = (dT) => {
    y -= 500 * (0.5 - anim) * dT;
    cs += cs * 3.0 * (0.5 - anim) * dT;
    anim += dT * 1.2;
    if (anim > 0.5) {
      this.destroyed = true;
    }
  };
  this.render = (ctx) => {
    drawCard(ctx, x, y, cs, card, false, (0.5 - anim) * 2);
  };
}

function PullCard(engine, x, y, card, cs, slot) {
  var anim = -0.5;

  this.update = (dT) => {
    anim += dT * 3;
    if (anim > 1) {
      this.destroyed = true;
      bus.emit('place', {slot, card});
    }
  };
  this.render = (ctx) => {
    var maxOp = 0.15;
    if (engine.hasEnergy(card)) { maxOp = 1; }
    var p = Math.min(Math.max(anim, 0), 1);
    drawCard(
      ctx,
      x * p * p + width()/2 * (1 - p * p),
      y * p * p + height() * (1 - p * p),
      cs * p,
      card,
      false,
      p * maxOp
    );
  };
}

function Asteroid(engine, tick, slot) {
  var anim = Math.random() * 100;
  this.x = 0;
  this.y = 0;
  this.obstacle = true;

  this.update = (dT) => {
    anim += dT * 0.1;
    this.x = engine.laneX(tick);
    this.y = engine.laneY(slot);
    if (engine.getTick() > tick + 6) {
      this.destroyed = true;
    }
    if (engine.closeToShip(engine.laneX(tick), engine.laneY(slot), 2)) {
      this.destroyed = true;
      bus.emit('hit', 1);
    }
  };
  this.render = (ctx) => {
    ctx.save();
    ctx.translate(this.x, this.y);
    var s = engine.laneScale() * 1.0;
    ctx.fillStyle = '#963';
    // debris trail
    for (let i = 0; i < 8; i++) {
      ctx.beginPath();
      ctx.arc(
        (i + 0.7) * s * 0.3 + Math.sin(anim*3+i*i*4)*s*0.6,
        Math.sin(anim*5+i*i*4)*s*0.7,
        s * 0.6 / (1.0 + i * 1.0),
        0, 6.29);
      ctx.fill();
    }
    // asteroid
    ctx.beginPath();
    ctx.arc(0, 0, s, 0, 6.29);
    ctx.fill();
    ctx.restore();
  };
}

function Mineral(engine, tick, slot, type) {
  var anim = Math.random() * 100;
  this.x = 0;
  this.y = 0;
  var homing = false;
  var ht = 0;
  var value = 1;
  if (Math.random() > 0.6) {
    value = 3;
    if (Math.random() > 0.6) {
      value = 7;
    }
  }
  var mineFn = () => {
    homing = true;
    bus.emit('poof', {x: this.x, y: this.y, color: [255,130,255], size: 0.6, t: 0.3});
    bus.off('mine', mineFn);
  };
  bus.on('mine', mineFn);

  this.update = (dT) => {
    anim += dT * 1.0;
    if (homing) {
      var dx = engine.getShipX() - this.x;
      var dy = engine.getShipY() - this.y;
      var m = Math.sqrt(dx*dx+dy*dy);
      var s = width() * ht;
      ht += dT;
      this.x += dx/m*s*dT;
      this.y += dy/m*s*dT;
    } else {
      this.x = engine.laneX(tick);
      this.y = engine.laneY(slot);
    }
    if (engine.getTick() > tick + 6 && !homing) {
      this.destroyed = true;
      bus.off('mine', mineFn);
    }
    if (engine.closeToShip(this.x, this.y, 1.4)) {
      this.destroyed = true;
      bus.off('mine', mineFn);
      bus.emit('mineral', value);
    }
  };
  this.render = (ctx) => {
    var s = engine.laneScale();
    if (value == 1) {
      drawMineral(ctx, this.x, this.y, anim, s * 0.4);
    } else if (value == 3) {
      drawMineral(ctx, this.x-s/3, this.y, anim, s * 0.3);
      drawMineral(ctx, this.x+s/3, this.y-s/2, anim, s * 0.3);
      drawMineral(ctx, this.x+s/3, this.y+s/2, anim, s * 0.3);
    } else if (value == 7) {
      for (let i = 0; i < 6; i++) {
        drawMineral(ctx, this.x+Math.sin(i*1.04)*s*0.8, this.y+Math.cos(i*1.04)*s*0.8, anim, s * 0.25);
      }
      drawMineral(ctx, this.x, this.y, anim, s * 0.3);
    }
  };
}

function Projectile(engine, x, y, targetLane, projectileType) {
  var anim = 0;
  this.x = x;
  this.y = y;
  var trail = [];

  this.update = (dT) => {
    anim += dT * 1.0;
    // Nuke
    if (projectileType == 5) {
      this.x += dT * width() * (1 - anim/0.35);
      if (anim > 0.35) {
        // Destroy all obstacles
        get().forEach((g) => {
          if (g.obstacle) {
            g.destroyed = true;
            bus.emit('poof', {x: g.x, y: g.y, color: [255,50,50], size: 1, t: 0.5});
          }
        });
        // A bunch of poof
        var w = width(), h = height(), n = Math.sqrt(w*h)/20;
        for (let i = 0; i < n; i++) {
          bus.emit('poof', {x: Math.random()*w, y: Math.random()*h, color: [255,244,50], size: Math.random()*1+1, t: Math.random()*0.4+0.4});
        }
        // For audio cue...
        bus.emit('boom');
        this.destroyed = true;
      }
    }
    // Forward-moving projectiles
    else if (projectileType != 2) {
      if (projectileType != 4) {
        this.x += dT * width() / 2;
      } else {
        // crazy rockets homing
        var angle = Math.sin(Date.now()/30)*0.4;
        if (this.homing && !this.homing.destroyed) {
          angle += Math.atan2(this.homing.y-this.y, this.homing.x-this.x);
        }
        this.y += dT * width()*0.8 * Math.sin(angle);
        this.x += dT * width()*0.8 * Math.cos(angle);
      }
      if (anim > 4) {
        this.destroyed = true;
      }
      if (engine.collideTargets(this.x, this.y, 1.5)) {
        this.destroyed = true;
        // Audio cue...
        bus.emit('boom');
        if (projectileType == 1) {
          bus.emit('poof', {x: this.x, y: this.y, color: [255,200,100], size: 1, t: 0.5});
        }
        if (projectileType == 3) {
          bus.emit('poof', {x: this.x, y: this.y, color: [100,255,100], size: 1, t: 0.5});
        }
        if (projectileType == 4) {
          bus.emit('poof', {x: this.x, y: this.y, color: [255,200,140], size: 0.6, t: 0.5});
        }
      }
    }
    // Laser beam
    else {
      var s = engine.laneScale();
      var ly = engine.getShipY();
      var lx = engine.getShipX();
      get().forEach((g) => {
        if (g.obstacle) {
          var dy = ly - g.y;
          if (dy * dy < s * s && g.x>lx && !g.destroyed) {
            g.destroyed = true;
            bus.emit('poof', {x: g.x, y: ly, color: [50,130,255], size: 0.7, t: 0.5});
          }
        }
      });
      if (anim > 1) {
        this.destroyed = true;
      }
    }
  };
  this.render = (ctx) => {
    ctx.save();
    var s = engine.laneScale();

    // KEPLER MISSILE
    if (projectileType == 1) {
      ctx.fillStyle='#fff';
      ctx.translate(this.x, this.y);
      ctx.fillRect(-s*0.2,-s*0.2,s*1.2,s*0.4);
      ctx.fillRect(-s*0.4,-s*0.35,s*0.4,s*0.2);
      ctx.fillRect(-s*0.4,s*0.15,s*0.4,s*0.2);
      ctx.fillStyle='#fa3';
      // Flicker flame
      if (Math.sin(Date.now() / 14) > 0) {
        ctx.fillRect(-s*0.3,-s*0.05,-s*0.8,s*0.1);
      }
    }

    // SIGMA CANNON
    if (projectileType == 2) {
      ctx.translate(engine.getShipX(), engine.getShipY());
      ctx.fillStyle='#338';
      ctx.fillRect(s*0.8,-s*0.3,s*0.6,s*0.6);
      ctx.fillRect(s*0.9,-s*0.2,width(),s*0.4);
      ctx.fillStyle='#3af';
      if (Math.sin(Date.now() / 14) > 0) {
        ctx.fillRect(s,-s*0.1,width(),s*0.2);
        ctx.fillRect(s*0.9,-s*0.2,s*0.4,s*0.4);
      }
    }

    // PULSE BREAKER
    if (projectileType == 3) {
      ctx.fillStyle='#383';
      ctx.translate(this.x, this.y);
      ctx.beginPath();
      ctx.arc(0, 0, s*0.6, 0, 6.29);
      ctx.fill();
      // Flicker flame
      if (Math.sin(Date.now() / 14) > 0) {
        ctx.fillStyle='#8f8';
        ctx.beginPath();
        ctx.arc(0, 0, s*0.4, 0, 6.29);
        ctx.fill();
      }
    }

      // CRAZY ROCKETS
    if (projectileType == 4) {
      ctx.fillStyle='#fa4';
      ctx.beginPath();
      ctx.arc(this.x, this.y, s*0.3, 0, 6.29);
      ctx.fill();
      trail.unshift({x: this.x, y: this.y});
      if (trail.length > 14) { trail.pop(); }
      ctx.lineWidth = s * 0.1;
      ctx.strokeStyle='#fa4';
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      for (let i = 0; i < trail.length; i++) {
        ctx.lineTo(trail[i].x, trail[i].y);
      }
      ctx.stroke();
    }

    // TACTICAL NUKE
    if (projectileType == 5) {
      ctx.fillStyle='#ff0';
      ctx.translate(this.x,this.y);
      ctx.beginPath();
      ctx.arc(0, 0, s*0.4, 0, 6.29);
      ctx.fill();
      ctx.fillStyle='#333';
      ctx.fillRect(-s*0.2, -s*0.2, s*0.4, s*0.4);
    }

    ctx.restore();
  };
}

function Poof(engine, x, y, color, size, duration) {
  var anim = 0;

  this.update = (dT) => {
    anim += dT * 1.0;
    if (anim > duration) {
      this.destroyed = true;
    }
  };
  this.render = (ctx) => {
    ctx.save();
    var s = engine.laneScale();
    ctx.translate(x, y);
    ctx.beginPath();
    var opacity = 1 - anim/duration;
    var p = 0.5 + 1.5 * (1 - Math.exp(-anim/duration*3));
    ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${opacity})`;
    ctx.arc(0,0,size*s*p,0,6.29);
    ctx.fill();
    ctx.restore();
  };
}

function Engine() {
  var currLevel = persist.getLevel();

  // Card handling
  var cloneCard = (card) => Object.assign({}, card);
  var shuffle = (d) => d.sort(() => Math.random() - 0.5);
  var removeFromHand = (idx) => {
    discardPile.push(hand[idx]);
    hand[idx] = null;
  };
  var pullFromDeckToSlot = (slot) => {
    var idx = parseInt(Math.random() * deck.length);
    var pulledCard = deck[idx];
    deck.splice(idx, 1);

    // pull card animation
    var w = width();
    var h = height();
    var cs = getCardScale(w, h);
    var x = getCardPosX(slot, cs, w);
    var y = getCardPosY(h);
    add(new PullCard(this, x, y, pulledCard, cs, slot));

    // reshuffle deck
    if (deck.length == 0) {
      deck = discardPile;
      shuffle(deck);
      discardPile = [];
    }
  };
  var getCardScale = (w, h) => Math.min(w * (0.95 / (1 + handSize)), h * 0.185);
  var getCardPosX = (q, cs, w) => w * 0.5 + (q - (handSize - 1) / 2) * cs * 1.17;
  var getCardPosY = (h) => h * 0.735;

  // The cards in the deck
  var deck = persist.getDeck().map(cloneCard);
  var discardPile = [];
  shuffle(deck);

  // The cards in hand
  var handSize = persist.getHandSize();
  var hand = [];
  for (let i = 0; i < handSize; i++) {
    pullFromDeckToSlot(i);
  }
  var hovering = -1;

  // Ship position
  var currentLane = 1;
  var laneAnim = 1;
  var shipAngle = 0;
  var dashing = 0;
  var dashSpeed = 0;

  // Shields = HP, Energy = MP
  var maxShield = persist.getMaxShield();
  var shield = maxShield;
  var maxEnergy = persist.getMaxEnergy();
  var energy = maxEnergy;
  var energyRefill = 0;
  var energyRefillRate = 0.75;

  var totalTicks = 20 + currLevel * 2;
  var currentTick = 0;
  var tickAnim = 0;
  var anim = 0;

  // events handlers
  // HOVERING animation may be worth removing for some bytes :O
  const getHoverIndex = (evt) => {
    const w = width();
    const h = height();
    const mx = evt.x, my = evt.y;

    var hov = -1;
    var cardsInHand = hand.length;
    var cs = Math.min(w * (0.95 / (1 + cardsInHand)), h * 0.185);

    for (let q = 0; q < cardsInHand; q++) {
      var x = w * 0.5 + (q - (cardsInHand - 1) / 2) * cs * 1.17;
      var y = h * 0.735;
      if (mx > x - cs/2 && mx < x + cs/2 && my > y - cs*3/4 && my < y + cs*3/4) {
        hov = q;
      }
    }
    return hov;
  };

  bus.on('tap', (evt) => {
    var hov = getHoverIndex(evt);
    if (hov>=0 && hand[hov] != null) {
      cost = hand[hov].cost;
      if (energy >= cost) {
        energy -= cost;
        hand[hov].use();
        var w = width();
        var h = height();
        var cs = getCardScale(w, h);
        var x = getCardPosX(hov, cs, w);
        var y = getCardPosY(h);
        add(new PlayedCard(x, y, hand[hov], cs));
        removeFromHand(hov);
        pullFromDeckToSlot(hov);
      }
    }
  });

  bus.on('move', (evt) => {
    hovering = getHoverIndex(evt);
  });

  bus.on('lane', (lane) => {
    currentLane = lane;
  });

  bus.on('hop', () => {
    var newLane = currentLane;
    while (newLane == currentLane) {
      newLane = parseInt(Math.random() * 3);
    }
    var sx = this.getShipX();
    var sc = this.laneScale();
    for (let i = 0; i < 3; i++) {
      sz = 0.3;
      var col = [255, 0, 255];
      if (i == newLane) { sz = 1; col = [100, 255, 100]; }
      add(new Poof(this, sx+sc*2, this.laneY(i), col, sz, 0.7));
    }
    currentLane = newLane;
  });

  bus.on('dash', () => {
    dashing = 0.5;
    dashSpeed = 2;
  });

  bus.on('hyper', () => {
    dashing = 0.4;
    dashSpeed = 10;
  });

  bus.on('persist-max-shield', () => { persist.setMaxShield(persist.getMaxShield() + 1); });
  bus.on('persist-max-energy', () => { persist.setMaxEnergy(persist.getMaxEnergy() + 1); });
  bus.on('persist-max-hand', () => { persist.setHandSize(persist.getHandSize() + 1); });

  bus.on('heal', () => {
    shield = Math.min(shield + 1, maxShield);
    add(new Poof(this, this.getShipX(), this.getShipY(), [0, 255, 0], 1, 0.5));
  });

  bus.on('poof', ({x, y, color, size, t}) => {
    add(new Poof(this, x, y, color, size, t));
  });

  bus.on('projectile', (projectileType) => {
    // Kepler Missile, Sigma Cannon, Tactical Nuke
    if (projectileType == 1 || projectileType == 2 || projectileType == 5) {
      add(new Projectile(this, this.getShipX(), this.getShipY(), currentLane, projectileType));
    }
    // Pulse breaker
    if (projectileType == 3) {
      add(new Projectile(this, this.getShipX(), this.laneY(0), 0, projectileType));
      add(new Projectile(this, this.getShipX(), this.laneY(1), 1, projectileType));
      add(new Projectile(this, this.getShipX(), this.laneY(2), 2, projectileType));
    }
    // Crazy Rockets
    if (projectileType == 4) {
      var s = this.laneScale();
      var p1 = new Projectile(this, this.getShipX(), this.getShipY()-s/2, currentLane, projectileType);
      var p2 = new Projectile(this, this.getShipX(), this.getShipY()+s/2, currentLane, projectileType);
      var targets = get().filter((g) => g.obstacle && g.x > s*3);
      var idx = parseInt(Math.random() * targets.length);
      p1.homing = targets[idx]; targets.splice(idx,1);
      var idx = parseInt(Math.random() * targets.length);
      p2.homing = targets[idx]; targets.splice(idx,1);
      add(p1);
      add(p2);
    }
  });

  bus.on('place', ({slot, card}) => {
    hand[slot] = card;
  });

  bus.on('hit', (dmg) => {
    shield -= dmg;
    if (shield <= 0) {
      bus.emit('transition-scene', 4);
    }
    bus.emit('poof', {x: this.getShipX(), y: this.getShipY(), color: [255,255,255], size: 1, t: 0.5});
  });

  bus.on('mineral', (m) => {
    persist.addMineral(m);
  });

  // Actually put stuff on the playing field.
  var generateContent = () => {
    if (currentTick > totalTicks - 7 || dashSpeed > 4) {
      return;
    }
    var lanes = {};

    // Asteroid (more frequent as levels progress)
    for (let q = 0; q < 0.1 + currLevel * 0.15; q++) {
      if (Math.random() > 0.7 / (1 + currLevel * 0.04)) {
        var lane = parseInt(Math.random()*3);
        if (!lanes[lane]) {
          lanes[lane] = 1;
          add(new Asteroid(this, currentTick, lane));
        }
      }
    }

    // Minerals
    if (Math.random() > 0.6) {
      var lane = parseInt(Math.random()*3);
      if (!lanes[lane]) {
        lanes[lane] = 1;
        add(new Mineral(this, currentTick, lane, 1));
      }
    }
  };

  this.hasEnergy = (card) => energy >= card.cost;

  this.laneY = (slot) => {
    var h = height();
    if (slot == 0) return h * 0.18;
    if (slot == 1) return h * 0.34;
    return h * 0.5;
  };

  this.laneX = (tick) => {
    var w = width();
    var ticksInView = 5;
    var shipX = 50 + w/40 + this.laneScale();
    return shipX + (1 - (currentTick + tickAnim - tick) / ticksInView) * (w + shipX);
  };

  this.laneScale = () => {
    var w = width(), h = height();
    const ph = h * 0.16;
    return Math.min(ph, w/8) * 0.3;
  };

  this.getTick = () => currentTick;

  this.getShipX = () => {
    var w = width();
    return 50 + w/40 + this.laneScale();
  };

  this.getShipY = () => {
    var h = height();
    return h * 0.18 + laneAnim * h * 0.16;
  };

  this.closeToShip = (x, y, dist) => {
    if (dashing > 0) return false;
    var s = this.laneScale();
    var dx = x - this.getShipX();
    var dy = y - this.getShipY();
    return dx * dx + dy * dy < s * s * dist;
  };

  this.collideTargets = (x, y, dist) => {
    var s = this.laneScale();
    var hit = false;
    get().forEach((g) => {
      if (g.obstacle) {
        var dx = x - g.x;
        var dy = y - g.y;
        if (dx * dx + dy * dy < s * s * dist) {
          hit = true;
          g.destroyed = true;
        }
      }
    });
    return hit;
  };

  this.update = (dT) => {
    anim += dT;
    if (anim > 1) {
      if (dashing > 0) {
        dashing -= dT;
        tickAnim += dT * dashSpeed;
        anim += dT * dashSpeed * 2;
      } else {
        dashSpeed = 0;
      }
      tickAnim += dT * 2;
    }
    if (tickAnim > 1) {
      tickAnim--;
      currentTick++;
      generateContent();

      // Journey finished -- visit planet now
      if (currentTick > totalTicks) {
        // 13'th zero indexed planet ==> Korva-6
        if (currLevel == 13) {
          // Victory!
          bus.emit('transition-scene', 5);
        } else {
          // Planet Event
          bus.emit('transition-scene', 3);
        }
      }
    }

    // Energy refill
    if (energy < maxEnergy) {
      energyRefill += energyRefillRate * dT;
      if (energyRefill >= 1) {
        energyRefill -= 1;
        energy++;
      }
    } else {
      energyRefill = 0;
    }

    // Animate tween
    shipAngle += ((currentLane - laneAnim) * 0.5 - shipAngle) * 7.0 * dT;
    laneAnim += (currentLane - laneAnim) * 5.0 * dT;
  };

  this.render = (ctx) => {
    // Screen dimensions
    const w = width();
    const h = height();

    // Lane placements (PillWidth, PillHeight, Top, Mid, Bottom)
    const pw = w / 40;
    const ph = h * 0.16;
    const th = h * 0.1;
    const mh = th + ph;
    const bh = mh + ph;

    // Scale of the art
    const s = Math.min(ph, w/8) * 0.3;

    // Starmap
    drawStars(ctx, -anim*20, 0, 3 + dashSpeed, 0);

    // Planets
    var r = h * 0.3;
    ctx.fillStyle = '#224';
    ctx.beginPath();
    ctx.arc(-(currentTick + tickAnim) / 10 * w, h * 0.34, r, 0, 6.28);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(-(currentTick + tickAnim - totalTicks) / 10 * w + w*0.4, h * 0.34, r, 0, 6.28);
    ctx.fill();

    // Minimap
    // Progress path
    var pr=h*0.02;
    ctx.fillStyle = '#446';
    ctx.fillRect(15 + pw, th/2, w - 30 - 2*pw, 1);
    // Source planet
    ctx.fillStyle = '#446';
    ctx.beginPath();
    ctx.arc(15 + pr, th/2, pr, 0, 6.28);
    ctx.fill();
    // Dest planet
    ctx.fillStyle = '#446';
    ctx.beginPath();
    ctx.arc(w - 15 - pr, th/2, pr, 0, 6.28);
    ctx.fill();
    // Progress ship
    ctx.fillStyle = '#fff';
    var px = 15 + pw + (w - 30 - 2*pw) * ((currentTick + tickAnim)/(totalTicks+1));
    ctx.beginPath();
    ctx.moveTo(px+pw/3, th/2);
    ctx.lineTo(px-pw/3, th/2-pw/3);
    ctx.lineTo(px-pw/3, th/2+pw/3);
    ctx.closePath();
    ctx.fill();

    // Draw the lanes
    ctx.fillStyle = '#f33'; ctx.fillRect(15, th, pw, ph);
    ctx.fillStyle = '#3f3'; ctx.fillRect(15, mh, pw, ph);
    ctx.fillStyle = '#33f'; ctx.fillRect(15, bh, pw, ph);
    ctx.fillStyle = '#f33'; ctx.fillRect(w-15, th, -pw, ph);
    ctx.fillStyle = '#3f3'; ctx.fillRect(w-15, mh, -pw, ph);
    ctx.fillStyle = '#33f'; ctx.fillRect(w-15, bh, -pw, ph);
    ctx.fillStyle = 'rgba(100,100,100,0.4)';
    ctx.fillRect(15, th, w-30, 1);
    ctx.fillRect(15, mh, w-30, 1);
    ctx.fillRect(15, bh, w-30, 1);
    ctx.fillRect(15, bh+ph, w-30, 1);

    // Draw the main ship
    ctx.save();

    // base ship position
    ctx.translate(50 + pw + s, th + ph/2 + laneAnim * ph );
    ctx.rotate(shipAngle);

    // ship flames
    for (let i = 5; i >= 0; i--) {
      if (i < 1) {
        ctx.fillStyle = '#fd6';
      } else if (i < 3) {
        ctx.fillStyle = '#fa1';
      } else {
        ctx.fillStyle = '#a41';
      }
      ctx.beginPath();
      var spot = (Math.sin(anim*(i+1)*20) * 0.2 + 0.5);
      ctx.arc(-s - s * i * 0.1, Math.sin(-anim*40+i)*i*s/30, (s * spot) / (1.5 + i*0.3), 0, 6.29);
      ctx.fill();
    }

    // ship body + shaking
    ctx.translate(Math.sin(anim*30) * s/60, Math.sin(anim*35) * s/40);
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(s, 0);
    ctx.lineTo(-s*0.65,-s*0.8);
    ctx.lineTo(-s*0.65,-s*0.3);
    ctx.lineTo(-s,-s*0.5);
    ctx.lineTo(-s,s*0.5);
    ctx.lineTo(-s*0.65,s*0.3);
    ctx.lineTo(-s*0.65,s*0.8);
    ctx.closePath();
    if (dashing > 0) {
      ctx.lineWidth = s * 0.1;
      ctx.strokeStyle = '#fff';
      ctx.stroke();
    } else {
      ctx.fill();
    }
    ctx.fillRect(-s*0.4,s*0.4,s,s*0.15);
    ctx.fillRect(-s*0.4,-s*0.4,s,-s*0.15);
    ctx.restore();

    // Draw energy
    var uiScale = Math.min(h * 0.025, w*0.035);
    var shieldTextLevel = h - uiScale;
    ctx.textBaseline = 'bottom';
    ctx.font = `${uiScale}px monospace`;
    ctx.textAlign = 'right';
    ctx.fillStyle = '#ff3';
    ctx.fillText('Energy', w - pw, shieldTextLevel);
    ctx.textAlign = 'right';
    ctx.fillText(energy, w - (pw + uiScale * 6), shieldTextLevel);
    ctx.textAlign = 'left';
    ctx.fillStyle = '#888';
    ctx.font = `${uiScale*0.8}px monospace`;
    ctx.fillText(`/ ${maxEnergy}`, w - (pw + uiScale * 5.7), shieldTextLevel);
    var cellWidth = uiScale * 1.2;
    for (let i = 0; i < maxEnergy; i++) {
      var sx = w - (pw + i * (cellWidth*0.8 + 4) + cellWidth);
      var sy = shieldTextLevel - cellWidth*2.4;
      drawEnergy(ctx, sx, sy, cellWidth, i < energy);
    }
    // energy refill meter
    ctx.fillStyle = '#333';
    var fillMeterScale = (cellWidth*0.8 + 4) * maxEnergy;
    ctx.fillRect(w - pw, shieldTextLevel - cellWidth*1.07, -fillMeterScale, 2);
    ctx.fillStyle = '#ff3';
    ctx.fillRect(w - pw, shieldTextLevel - cellWidth*1.07, -energyRefill * fillMeterScale, 2);

    // Draw shield
    var cellRadius = uiScale * 0.6;
    var energyTextLevel = h - uiScale;
    ctx.textBaseline = 'bottom';
    ctx.font = `${uiScale}px monospace`;
    ctx.textAlign = 'left';
    ctx.fillStyle = '#3ff';
    ctx.fillText('Shield', pw, energyTextLevel);
    ctx.textAlign = 'right';
    ctx.fillText(shield, pw + uiScale * 5.3, energyTextLevel);
    ctx.textAlign = 'left';
    ctx.fillStyle = '#888';
    ctx.font = `${uiScale*0.8}px monospace`;
    ctx.fillText(`/ ${maxShield}`, pw + uiScale * 5.6, energyTextLevel);
    for (let i = 0; i < maxShield; i++) {
      var sx = pw + i * (cellRadius*2.5 + 4) + cellRadius;
      var sy =  energyTextLevel - cellRadius*4;
      drawShield(ctx, sx, sy, cellRadius, i < shield);
    }

    // Draw mineral count
    var mineralTextLevel = h - uiScale;
    ctx.textBaseline = 'bottom';
    ctx.font = `${uiScale}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#f3f';
    ctx.fillText(persist.getMinerals(), w*0.4, mineralTextLevel);
    drawMineral(ctx, w*0.4, mineralTextLevel-uiScale*2.1,0.785,uiScale*0.5);

    // Draw deck size remaining
    ctx.fillStyle = '#aaa';
    ctx.fillText(deck.length, w*0.6, mineralTextLevel);
    drawDeck(ctx, w*0.6, mineralTextLevel-uiScale*2.1,uiScale*0.4);

    // Draw cards
    var cardsInHand = hand.length;
    var cs = getCardScale(w, h);
    for (let q = 0; q < cardsInHand; q++) {
      if (hand[q] == null) continue;
      var x = getCardPosX(q, cs, w);
      var y = getCardPosY(h);
      var opacity = 1;
      if (energy < hand[q].cost) { opacity = 0.15; }
      drawCard(ctx, x, y, cs, hand[q], hovering == q, opacity);
    }
  };
}

function pick(l) {
  return l[parseInt(Math.random() * l.length)];
}

const planets = [
  'Tenadu',
  'Nurosto Prime',
  'Worlax',
  'Mektrov Zero',
  'Cytoxia',
  'Broggendor',
  'Voitec',
  'Helion',
  'Earth (Remnants)',
  'Yonzi Mata',
  'Streva Gateway',
  'Lumatorr',
  'Desela',
  'Korva-6'
];

function PlanetEvent() {
  // Planet label
  var currLevel = persist.getLevel();
  add(new Text(`Planet ${planets[currLevel]}`,
    ()=>width()*0.03, ()=>width()*0.05, '#fff', 0.5, 'left'));

  // Start button
  add(new StartButton());
  bus.on('start', () => {
    // Increment level
    persist.setLevel(persist.getLevel() + 1);
    bus.emit('transition-scene', 2);
  });

  // Handlers
  onTapCard = ({x, y}) => {
    var w = width();
    var h = height();
    var m = persist.getMinerals();
    var cs = Math.min(h*0.2, w*0.25);
    for (let i = 0; i < items.length; i++) {
      var bx = w/2 + (i - (items.length - 1)/2) * w * 0.3;
      if (items[i] != null && m >= items[i].price) {
        if (x > bx-cs/2 && x < bx+cs/2 && y > h*0.4-cs*3/4 && y < h*0.4+cs*3/4) {
          add(new PlayedCard(bx, h*0.4, items[i], cs));
          persist.addMineral(-items[i].price);
          bus.emit('buy');
          // Templar does not add cards to deck
          if (evtType == 4) {
            items[i].use();
          } else {
            // All other shops add cards to deck
            persist.addToDeck(items[i]);
          }
          items[i] = null;
        }
      }
    }
  };

  // Event types
  var evtType = [];
  if (currLevel == 0) {
    // Only allow weapon tech and merchant for first level
    evtType = pick([0, 2]);
  } else {
    // All shops are fair game after
    evtType = pick([0, 1, 2, 3, 4]);
  }
  // TBD: Prevent increasing blessings to comical scales?
  var items = [];
  var merchantName = '';
  var merchantGfx = drawCharWeaponTech;
  var merchantText = '';

  // [EVT == 0] WEAPON TECH
  if (evtType == 0) {
    // weapon cards
    merchantName = 'Weapon Tech';
    merchantGfx = drawCharWeaponTech;
    merchantText = pick([
      'Stop staring human! Either buy something or leave.',
      'Rockets! Laser beams! What are you looking for? I\'ve got it all.',
      'Hey hey, don\'t touch the merchandise! You might hurt yourself...'
    ]);
    var selection = [cards[3], cards[4], cards[5], cards[6], cards[7]];
    var numCardsInShop = parseInt(Math.random() * 2) + 2;
    for (let i = 0; i < numCardsInShop; i++) {
      items.push(selection[parseInt(Math.random() * selection.length)]);
    }
    bus.on('tap', onTapCard);
  }

  // [EVT == 1] SHIP MECHANIC
  if (evtType == 1) {
    // ship upgrade cards
    merchantName = 'Ship Mechanic';
    merchantGfx = drawCharShipMech;
    merchantText = pick([
      'Beep Boop - May I assist you with upgrades for that spacefaring vessel?',
      'Zip Zap - Your shield generator looks a bit flimsy. I can help with that.',
      'Wrrrrr - Do you call that piece of scrap metal a ship?',
    ]);
    var selection = [cards[8], cards[9], cards[10], cards[11], cards[12]];
    var numCardsInShop = parseInt(Math.random() * 2) + 2;
    for (let i = 0; i < numCardsInShop; i++) {
      items.push(selection[parseInt(Math.random() * selection.length)]);
    }
    bus.on('tap', onTapCard);
  }

  // [EVT == 2] Street MERCHANT
  if (evtType == 2) {
    // mix of low tech card
    merchantName = 'Street Merchant';
    merchantGfx = drawCharMerchant;
    merchantText = pick([
      'Pssst. Yeah you. You look like you could use a pumpjack for that ship.',
      'Only the best mechatronics here. Forged from the finest Worlax Steel.',
      'Got this stuff from the Gateway District... You\'re not a cop right?',
    ]);
    var selection = [cards[3], cards[4], cards[8], cards[9]];
    var numCardsInShop = parseInt(Math.random() * 2) + 2;
    for (let i = 0; i < numCardsInShop; i++) {
      items.push(selection[parseInt(Math.random() * selection.length)]);
    }
    bus.on('tap', onTapCard);
  }

  // [EVT == 3] BLACK MARKET
  if (evtType == 3) {
    // mix of high tech card
    merchantName = 'Cytox Smuggler';
    merchantGfx = drawCharSmuggler;
    merchantText = pick([
      'Sssseems like you need ssssome black market tech. Letssss sssee what I\'ve got...',
      'Elzo Mineralsss are in short sssupply these daysss. My pricing hasss to ssslither up.',
      'This lot isn\'t my normal sssset of ssssuplies, but itsss much sssafer than the cccytox trade.',
    ]);
    var selection = [cards[5], cards[6], cards[10], cards[11]];
    var numCardsInShop = parseInt(Math.random() * 2) + 2;
    for (let i = 0; i < numCardsInShop; i++) {
      items.push(selection[parseInt(Math.random() * selection.length)]);
    }
    bus.on('tap', onTapCard);
  }

  // [EVT == 4] BLACK MARKET
  if (evtType == 4) {
    // grant max energy, max shield, hand size
    merchantName = 'Neuro-Templar';
    merchantGfx = drawCharTemplar;
    merchantText = pick([
      'I sense your journey has experienced rough patches. A blessing will surely aid you.',
      'The Great Consciousness has a gift for you, but an exchange of minerals must be made.',
      'Words from The Cortex will pave your road to enlightenment... for a small fee.',
    ]);
    var selection = [cards[13], cards[14], cards[15]];
    for (let i = 0; i < 2; i++) {
      var opt = parseInt(Math.random() * selection.length);
      items.push(selection[opt]);
      selection.splice(opt,1);
    }
    bus.on('tap', onTapCard);
  }

  this.drawCost = (ctx, txt, x, y, s, canAfford) => {
    ctx.fillStyle='#f3f';
    ctx.font=`${s*0.25}px monospace`;
    ctx.textAlign='left';
    ctx.textBaseline='middle';
    var tw = ctx.measureText(txt).width;
    var mw = s*0.061;
    var cx = (tw + mw*2)/2;
    ctx.fillText(txt, x+mw*3-cx, y+s);
    drawMineral(ctx,x+mw/2-cx,y+s,0.785,s*0.08);
    // Cross-out price line
    if (!canAfford) {
      ctx.save();
      ctx.fillStyle='rgba(255,0,0,0.7)';
      ctx.translate(x,y+s);
      ctx.rotate(0.1);
      ctx.fillRect(-s*0.5,-1,s,3);
      ctx.rotate(-0.2);
      ctx.fillRect(-s*0.5,-1,s,3);
      ctx.restore();
    }
  };

  this.render = (ctx) => {
    var w = width();
    var h = height();
    var m = persist.getMinerals();
    var hs = persist.getHandSize();
    var me = persist.getMaxEnergy();
    var ms = persist.getMaxShield();

    // Show characters
    drawCharPlayer(ctx);
    merchantGfx(ctx);
    drawDialogBox(ctx, merchantName, merchantText);

    // Show stats
    var us = Math.min(h*0.04,w*0.04);
    ctx.textAlign='left';
    ctx.textBaseline='middle';
    ctx.font=`${us}px monospace`;
    // Mineral stats
    drawMineral(ctx, us, h*0.75, 0.785, us*0.3);
    ctx.fillStyle='#f3f';
    ctx.fillText(m, us*1.7,h*0.75);
    // Hand stats
    drawDeck(ctx, us, h*0.75-us, us*0.2);
    ctx.fillStyle='#999';
    ctx.fillText(hs, us*1.7,h*0.75-us);
    // Shield stats
    drawShield(ctx, us, h*0.75-us*2, us*0.4, true);
    ctx.fillStyle='#3ff';
    ctx.fillText(ms, us*1.7,h*0.75-us*2);
    // Energy stats
    drawEnergy(ctx, us-us*0.325, h*0.75-us*3.45, us*0.8, true);
    ctx.fillStyle='#ff3';
    ctx.fillText(me, us*1.7,h*0.75-us*3);

    // Show items for interaction
    var cs = Math.min(h*0.2, w*0.25);
    for (let i = 0; i < items.length; i++) {
      if (items[i] != null) {
        var bx = w/2 + (i - (items.length - 1)/2) * w * 0.3;
        drawCard(ctx, bx, h*0.4, cs, items[i], false,1);
        this.drawCost(ctx, `${items[i].price}`, bx, h*0.4, cs, m >= items[i].price);
      }
    }
  };
}

function GameOver() {
  var currLevel = persist.getLevel();

  // Title card
  add(new Text('SHUTTLEDECK', ()=>width()/2, ()=>height()*0.2, '#fff', 1, 'center'));

  // Game over :(
  add(new Text('Game Over', ()=>width()/2, ()=>height()*0.35, '#f55', 1, 'center'));
  add(new Text(`Exploded approaching planet ${planets[currLevel]}`, ()=>width()/2, ()=>height()*0.6, '#f55', 0.4, 'center'));

  // Push to play again
  add(new Text('[ Press to retry ]', ()=>width()/2, ()=>height()*0.8, '#777', 0.5, 'center'));
  var fn = () => {
    bus.emit('transition-scene', 1);
    bus.off('tap', fn);
  };
  bus.on('tap', fn);

  // Starfield
  this.render = (ctx) => {
    var w = width();
    var h = height();
    var uiScale = Math.min(h * 0.03, w*0.03);
    drawStars(ctx,-Date.now()*0.03,0,3,0);

    // Progress meter
    ctx.lineWidth = uiScale * 0.2;

    // bg line
    ctx.strokeStyle='#555';
    ctx.beginPath();
    ctx.moveTo(w/2 - w*14/36, h/2);
    ctx.lineTo(w/2 + w*14/36, h/2);
    ctx.stroke();

    for (let i = 0; i < planets.length + 1; i++) {
      var x = (i - 7) * w / 18 + w/2;
      if (i <= currLevel) {
        ctx.beginPath();
        ctx.arc(x, h*0.5,uiScale*0.6,0,6.29);
        ctx.fillStyle='#fff';
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(x, h*0.5,uiScale*0.5,0,6.29);
        ctx.fillStyle='#000';
        ctx.strokeStyle='#f55';
        ctx.fill();
        ctx.stroke();
      }
    }
  };
}

function Win() {
  add(new Text('Planet Korva-6', ()=>width()*0.03, ()=>width()*0.05, '#fff', 0.5, 'left'));
  add(new Text('Package Delivered!', ()=>width()/2, ()=>height()/2, '#5f5', 0.6, 'center'));
  add(new StartButton('Main Menu'));
  bus.on('start', () => { bus.emit('transition-scene', 0); });

  this.render = (ctx) => {
    drawCharPlayer(ctx);
    drawCharZoren(ctx, '#f55');
    drawDialogBox(ctx,
      'Professor Quinn',
      'Is that a Xenotransponder?? My brother Zorn must have sent this. Thank you, Courier!'
    );
  };
}

// Init/Reset game
function init() { bus.emit('scene', 0); }

// Go to scene number
function transition(s) {
  bus.emit('txn');
  // When transition animation done, swap scene and perform fade in
  bus.on('txn-done', () => {
    bus.emit('scene', s);
    add(new transition$1(0.9, false));
    for (let i = 0; i < width(); i+=width()*0.01) {
      add(new Steam(i,height()/2));
    }
  });
  // Start transition animation and stop all updaters
  get().forEach((go) => {go.update=undefined;});
  add(new transition$1(0.4, true));
}

(() => {
  // Scene configuration
  var scene = 0;
  var sceneConfig = (sceneNum) => {
    scene = sceneNum;
    bus.clear();
    bus.on('scene', sceneConfig);
    bus.on('transition-scene', transition);
    audio.stopMusic();
    audio.setup();
    clear();

    // [SCENE = 0] MAIN MENU
    if (scene == 0) { add(new MainMenu()); }

    // [SCENE = 1] INTRO
    if (scene == 1) { add(new Intro()); audio.music(); }

    // [SCENE = 2] GAME
    if (scene == 2) { add(new Engine()); audio.bgRocket(); }

    // [SCENE = 3] PLANET EVENT
    if (scene == 3) { add(new PlanetEvent()); audio.music(); }

    // [SCENE = 4] LOSE SCREEN
    if (scene == 4) { add(new GameOver()); }

    // [SCENE = 5] WIN SCREEN
    if (scene == 5) { add(new Win()); }
  };

  bus.on('scene', sceneConfig);
})();

isMobile = ()=>/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

window.addEventListener('touchstart', (evt) => {
  evt.stopPropagation();
  bus.emit('tap', { x: evt.touches[0].clientX, y: evt.touches[0].clientY });
});

window.addEventListener('mousedown', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  if (!isMobile()) { bus.emit('tap', { x: evt.x, y: evt.y });}
});

window.addEventListener('mousemove', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  if (isMobile()) {
    bus.emit('move', { x: -1, y: -1 });
  } else {
    bus.emit('move', { x: evt.x, y: evt.y });
  }
});

init();

// Set up the favicon
(() => {
  var canvas = document.createElement('canvas');
  canvas.width = 64; canvas.height = 64;
  document.body.appendChild(canvas);
  var ctx = canvas.getContext('2d');
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, 64, 64);
  ctx.strokeStyle = '#fa3';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.strokeRect(0, 0, 64, 64);
  ctx.translate(31, 29);
  cards[3].glyph(ctx, 82, 0.05);
  var link = document.querySelector("link[rel~='icon']");
  link.href = canvas.toDataURL();
  document.body.removeChild(canvas);
})();

// Wrap in closure to allow variable minification.
(() => {
  // Game loop
  var lastTime = Date.now();
  var removeQueue = [];
  var noop = () => {};

  var gameloop = () => {
    // Compute frame time in seconds
    var currTime = Date.now();
    var dT = (currTime - lastTime) * 0.001;
    if (dT > 0.3) { dT = 0.3; }

    // Clear frame
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width(), height());

    // Update, render, and queue game object removal
    removeQueue.length = 0;
    get().forEach((g) => {
      (g.ecs || []).forEach((u) => u(dT));
      (g.update || noop)(dT);
      (g.render || noop)(ctx);
      if (g.destroyed) { removeQueue.push(g); }
    });

    // Remove objects enqueued from before
    removeQueue.forEach((x) => remove(x));

    // Request next frame
    lastTime = currTime;
    requestAnimationFrame(gameloop);
  };
  gameloop();
})();
</script></html>